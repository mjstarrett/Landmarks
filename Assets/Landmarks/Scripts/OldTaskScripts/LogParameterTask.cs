/*    Copyright (C) 2010  Jason Laczko    This program is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program.  If not, see <http://www.gnu.org/licenses/>.*/using UnityEngine;using System.Collections;using System;using System.Reflection;//public class ConfigFormatException: System.Exception {}//public class ConfigKeyFormatException: System.Exception {}//public class GameObjectNullException: System.Exception {}//public class ScriptNullException: System.Exception {}//public class MissingKeyException: System.Exception {}public class LogParameterTask : ExperimentTask {	public string description = "";	public string parameter = "";	public override void startTask () {		TASK_START();	}		public override void TASK_START()	{		//base.startTask();		//if (!manager) Start();	}				public override bool updateTask () {		string paramValue = "test";							string go = "";			string code = "";			string key = "";			string val = "";			string typestring = "";			string[] keyvalue = new string[1];			string[] parts = new string[1];						 try {						        parts = parameter.Trim().Split(new char[] {'.'},StringSplitOptions.RemoveEmptyEntries);		        		if (parts.Length != 3) throw new ConfigKeyFormatException();																        		go = parts[0];		        		code = parts[1];		        		key = parts[2];	        		 		       				        			GameObject taskObject = GameObject.Find(go);	        			if (!taskObject) throw new GameObjectNullException();	        									Component script = taskObject.GetComponent(code) as Component;	        			if (!script) throw new ScriptNullException();							Type valType;						BindingFlags flags;					 	FieldInfo fi = script.GetType().GetField(key,  BindingFlags.Instance | BindingFlags.Public);					 						 	// don't care if key is a field or property					 	if (fi ==  null )  {					 		PropertyInfo pi = script.GetType().GetProperty(key,  BindingFlags.Instance | BindingFlags.Public);					 		if (pi ==  null ) {					 			throw new MissingKeyException();					 		} else {						 		typestring = pi.PropertyType.ToString();						 		valType = pi.PropertyType;							 		flags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.GetProperty;					 		}					 	} else {					 		valType = fi.FieldType;						 	typestring = fi.FieldType.ToString();							 	flags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.GetField;						 	}						 						 						 	object o = script.GetType().InvokeMember(key, flags, null, script, null);					 			log.log("DATA\t" + description + "\t" + o.ToString() + "\t" ,1 );																					} catch (ConfigFormatException) {					Debug.Log("  Configuration '" +  "' has invalid format.\nValid config format is 'Session.Game Object name.Script Type.Variable = value'");	        	} catch (ConfigKeyFormatException) {	        		Debug.Log("  Configuration key '" + key.Trim() +  "' has invalid format.\nValid config format is 'Session.Game Object name.Script Type.Variable'");				} catch (GameObjectNullException) {        			Debug.Log("  Unable to find game object: " + go);				} catch (ScriptNullException) {        			Debug.Log("  Unable to find script: " + code);				} catch (MissingKeyException) {					Debug.Log("  Key: " + key  + " Not found in " + go + "." + code );						} catch (FormatException) {					Debug.Log("  Unable to set " + go + "." + code + "." + key + " to " + val + ". Was expecting to be formated for " + typestring);				} catch (InvalidCastException) {					Debug.Log("  Unable to convert " + val + " to " + typestring);				} catch (ArgumentException e) {					Debug.Log("Line: " + e.ToString());									}									    return true;	}		public override void endTask() {		//sTASK_END();	}		public override void TASK_END() {		//base.endTask();	}	}